buildscript {
    repositories {
        maven { url = 'https://files.minecraftforge.net/maven' }
        jcenter()
        mavenCentral()
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '3.+', changing: true
    }
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'maven-publish'

apply from: 'build.properties'

project.version = getVersion()
project.ext.shortVersion = getShortVersion()

repositories {
    // Put remote maven repositories here
}

// === Start workaround ForgeGradle not loading resources
// We will combine the outputs into one directory, so that it shows up as one entry on the classpath
// This is necessary to load resources with runClient
task combinedSource(type: Sync) {
    from sourceSets.main.output
    into "$buildDir/combined-classpath"
}

sourceSets {
    main {
        runtimeClasspath = files(combinedSource.outputs) + project.configurations.runtimeClasspath
    }
}
// === End workaround

minecraft {
    runs {
        client {
            workingDirectory project.file('run')
            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'
            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'
            // Debug connection for development
            jvmArgs += ["-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5016"]

            mods {
                mcanm {
                    source sourceSets.main
                }
            }
        }

        server {
            // Recommended logging data for a userdev environment
            property 'forge.logging.markers', 'SCAN,REGISTRIES,REGISTRYDUMP'
            // Recommended logging level for the console
            property 'forge.logging.console.level', 'debug'
            // Debug connection for development
            jvmArgs += ["-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=5017"]

            mods {
                mcanm {
                    source sourceSets.main
                }
            }
        }
    }
}

jar {
    manifest {
        attributes([
            "Specification-Title": project.archivesBaseName,
            "Specification-Vendor": "WorldSEnder",
            "Specification-Version": project.shortVersion,
            "Implementation-Title": project.name,
            "Implementation-Version": project.shortVersion,
            "Implementation-Vendor" :"WorldSEnder",
            "Implementation-Timestamp": new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
        ])
    }
}

processResources {
    from(sourceSets.main.resources.srcDirs) {
        include 'mcmod.info'
        expand project.properties
    }

    from(sourceSets.main.resources.srcDirs) {
        exclude 'mcmod.info'
    }
}

task processSource(type: Sync) {
    from(sourceSets.main.java) {
        include 'com/github/worldsender/mcanm/Reference.java'
        expand project.properties
    }
    from(sourceSets.main.java) {
        exclude 'com/github/worldsender/mcanm/Reference.java'
    }
    into "$buildDir/processed-src"
}

compileJava {
    source = processSource.outputs
}

jar.finalizedBy('reobfJar')

task sourceJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from jar.source
}

build.dependsOn sourceJar

artifacts {
    archives jar
    archives sourceJar
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            artifact jar
            artifact sourceJar
        }
    }
    repositories {
        maven {
            url "file:///${project.projectDir}/mcmodsrepo"
        }
    }
}

def getShortVersion() {
    def stdout = new ByteArrayOutputStream()
    exec {
        executable "git"
        args "rev-list", "--count", "HEAD"
        standardOutput = stdout
    }
    def revision = stdout.toString().trim() as Integer
    return "${major}.${minor}.${patch}.${revision}"
}

def getVersion() {
    return "${getShortVersion()}${getArtifactID()}+${project.mcversion}"
}

def getArtifactID() {
    def stdout = new ByteArrayOutputStream()
    exec {
        executable "git"
        args "rev-parse", "--abbrev-ref", "HEAD"
        standardOutput = stdout
    }
    def branch = stdout.toString().trim()
    def branchArtifact = branch != "HEAD" ? null : {
        stdout.reset()
        exec {
            executable "git"
            args "rev-parse", "--short", "HEAD"
            standardOutput = stdout
        }
        stdout.toString().trim().replace('/', '.')
    }()
    def isClean = exec({ executable "git"; args "diff", "--quiet"; ignoreExitValue = true }).exitValue == 0
    def dirtyArtifact = isClean ? null : "SNAPSHOT"
    def artifact = [branchArtifact, dirtyArtifact].findAll().join('.')
    return "${artifact == '' ? '' : '-' + artifact}"
}
